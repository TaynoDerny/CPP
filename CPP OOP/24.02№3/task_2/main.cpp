#include <iostream>
#include "Point.cpp"
#include "Fraction.cpp"
#include "Student.cpp"
using namespace std;

int main() {
    setlocale(LC_ALL, "Ru");
    
    cout << "=== ДЕМОНСТРАЦИЯ РАБОТЫ КЛАССОВ ===" << endl;
    cout << "===================================" << endl << endl;
    
    // Тестирование класса Point
    cout << "--- КЛАСС ТОЧКА (Point) ---" << endl;
    cout << "Текущее количество точек: " << Point::GetCount() << endl;
    
    Point p1;  // Конструктор по умолчанию (делегирование)
    Point p2(5, 10, 15);  // Конструктор с параметрами
    Point p3(p2);  // Конструктор копирования (делегирование)
    
    cout << "Точек создано: " << Point::GetCount() << endl;
    
    cout << "\n--- КЛАСС ДРОБЬ (Fraction) ---" << endl;
    cout << "Текущее количество дробей: " << Fraction::GetCount() << endl;
    
    Fraction f1;  // Конструктор по умолчанию (делегирование)
    Fraction f2(5);  // Конструктор с одним параметром (делегирование)
    Fraction f3(3, 4);  // Конструктор с параметрами
    Fraction f4(f3);  // Конструктор копирования (делегирование)
    
    cout << "Дробей создано: " << Fraction::GetCount() << endl;
    
    cout << "\n--- КЛАСС СТУДЕНТ (Student) ---" << endl;
    cout << "Текущее количество студентов: " << Student::GetCount() << endl;
    
    Student s1;  // Конструктор по умолчанию (делегирование)
    Student s2("Петров Петр Петрович");  // Конструктор только с ФИО (делегирование)
    Student s3("Сидоров Сидор Сидорович", "01.01.2000");  // Конструктор с ФИО и датой (делегирование)
    Student s4("Иванов Иван Иванович", "15.05.2000", "+7 (999) 123-45-67","Москва", "Россия", "МГУ", "Москва", "ИС-201");  // Полный конструктор
    Student s5(s4);  // Конструктор копирования (делегирование)
    
    cout << "Студентов создано: " << Student::GetCount() << endl;
    
    cout << "\n--- ВЫВОД ИНФОРМАЦИИ ---" << endl;
    cout << "\nСтудент 4 (полные данные):" << endl;
    s4.PrintStudent();
    
    cout << "\n=== ВЫХОД ИЗ ПРОГРАММЫ ===" << endl;
    cout << "Деструкторы будут вызваны автоматически" << endl;
    
    return 0;
}